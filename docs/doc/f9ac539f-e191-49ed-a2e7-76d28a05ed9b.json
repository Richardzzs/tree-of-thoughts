{
    "summary": "The code defines a `TreeofThoughts` class with JSON saving, logging, and BFS/DFS-based subclass for solving problems concurrently. It uses A* search, PriorityQueue, Monte Carlo tree search, transposition table, pruning, UCB1, and checks solution validity.",
    "details": [
        {
            "comment": "The code defines a class called TreeofThoughts with an init method that initializes object attributes, including a dictionary for the tree structure. It also includes methods to save the tree to JSON and log new states along with their associated thoughts or evaluations. The history attribute is added in the init method as an empty list.",
            "location": "\"/media/root/Prima/works/tree-of-thoughts/docs/src/tree_of_thoughts/treeofthoughts.py\":0-39",
            "content": "import concurrent.futures\nimport json\nimport logging\nimport os\nimport time\nfrom queue import PriorityQueue\nfrom typing import Any, Dict, Union\nimport numpy as np\nDATA_PATH = \"./data\"\nlogging.basicConfig(\n    level=logging.INFO, format=\"%(asctime)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\nclass TreeofThoughts:\n    def __init__(self, model):\n        self.model = model\n        self.tree: Dict[str, Dict[str, Union[float, Dict[str, Any]]]] = {\n            \"nodes\": {},\n        }\n        self.best_state = None\n        self.best_value = float(\"-inf\")\n        self.history = []  # added line initalize history\n    def save_tree_to_json(self, file_name):\n        os.makedirs(os.path.dirname(file_name), exist_ok=True)\n        with open(file_name, \"w\") as json_file:\n            json.dump(self.tree, json_file, indent=4)\n    def logNewState(self, state, evaluation):\n        if not (type(state) == str):\n            state = \" | \".join(state)\n        if state in self.tree[\"nodes\"]:\n            self.tree[\"nodes\"][state][\"thoughts\"].append(evaluation)"
        },
        {
            "comment": "This code defines a class `TreeofThoughtsBFS` that inherits from `TreeofThoughts`. It has methods for adjusting pruning thresholds based on percentile and moving average. The `solve()` method takes an initial prompt, number of thoughts, max steps, max states, value threshold, and pruning threshold. It uses BFS to explore the tree of thoughts.",
            "location": "\"/media/root/Prima/works/tree-of-thoughts/docs/src/tree_of_thoughts/treeofthoughts.py\":40-78",
            "content": "        else:\n            self.tree[\"nodes\"][state] = {\"thoughts\": [evaluation]}\n    def adjust_pruning_threshold_precentile(\n        self, evaluated_thoughts, percentile\n    ):\n        values = np.array(list(evaluated_thoughts.values()))\n        if values.size == 0:\n            return 0\n        return max(np.percentile(values, percentile), 0.1)\n    def adjust_pruning_threshold_moving_average(\n        self, evaluated_thoughts, window_size\n    ):\n        values = list(evaluated_thoughts.values())\n        if len(values) < window_size:\n            return np.mean(values) if values else 0\n        else:\n            return max(np.mean(values[-window_size:]), 0.1)\n######################\nclass TreeofThoughtsBFS(TreeofThoughts):\n    def solve(\n        self,\n        initial_prompt,\n        num_thoughts,\n        max_steps,\n        max_states,\n        value_threshold,\n        pruning_threshold=0.5,\n    ):\n        current_states = [initial_prompt]\n        state_values = {}\n        dynamic_pruning_threshold = pruning_threshold\n        try:"
        },
        {
            "comment": "This code uses a ThreadPoolExecutor to concurrently evaluate multiple thoughts generated from states. It selects thoughts from the current_states, submits them for evaluation, waits for the results, and filters out non-numeric results before storing the evaluated thoughts.",
            "location": "\"/media/root/Prima/works/tree-of-thoughts/docs/src/tree_of_thoughts/treeofthoughts.py\":79-99",
            "content": "            with concurrent.futures.ThreadPoolExecutor() as executor:\n                for step in range(1, max_steps + 1):\n                    selected_states = []\n                    for state in current_states:\n                        thoughts = self.model.generate_thoughts(\n                            state, num_thoughts, initial_prompt\n                        )\n                        futures = [\n                            executor.submit(\n                                self.model.evaluate_states,\n                                {thought: 0},\n                                initial_prompt,\n                            )\n                            for thought in thoughts\n                        ]\n                        concurrent.futures.wait(futures)\n                        evaluated_thoughts = {\n                            thought: fut.result()\n                            for thought, fut in zip(thoughts, futures)\n                            if isinstance(fut.result(), (int, float))\n                        }  # check if result is a number"
        },
        {
            "comment": "This code checks if there are evaluated thoughts and adjusts the pruning threshold based on them. It then loops through the evaluated thoughts, flattens the state with the thought (if the state is a string), and appends it to selected_states along with the value. The selected states are sorted by value in descending order, and only the top max_states are kept.",
            "location": "\"/media/root/Prima/works/tree-of-thoughts/docs/src/tree_of_thoughts/treeofthoughts.py\":101-121",
            "content": "                        if (\n                            evaluated_thoughts\n                        ):  # only adjust if you have evaluated thoughts\n                            dynamic_pruning_threshold = (\n                                self.adjust_pruning_threshold_moving_average(\n                                    evaluated_thoughts, 5\n                                )\n                            )\n                        for thought, value in evaluated_thoughts.items():\n                            flattened_state = (\n                                (state, thought)\n                                if isinstance(state, str)\n                                else (*state, thought)\n                            )\n                            selected_states.append((flattened_state, value))\n                        selected_states.sort(key=lambda x: x[1], reverse=True)\n                        selected_states = selected_states[\n                            :max_states\n                        ]  # Select only the top states"
        },
        {
            "comment": "This code block iterates through selected_states and assigns values to state_values if the value is above a certain threshold. It logs the state_values, and if there are values in state_values, it finds the highest rated solution, generates a solution using the model, and logs any errors that occur during this process.",
            "location": "\"/media/root/Prima/works/tree-of-thoughts/docs/src/tree_of_thoughts/treeofthoughts.py\":123-138",
            "content": "                        for state, value in selected_states:\n                            if value >= dynamic_pruning_threshold:\n                                state_values[state] = value\n                                self.logNewState(state, value)\n                                logger.debug(f\"State Values: {state_values}\")\n            # if state_values:\n            #     highest_rated_solution = max(state_values.items(), key=lambda x: x[1])\n            #     print(f\"highest rated solution: {highest_rated_solution}\")\n            #     highest_rated_state = highest_rated_solution[0]  # Use a different name to avoid confusion\n            #     print(f'highest rated state: {highest_rated_state}')\n            #     try:\n            #         solution = self.model.generate_solution(initial_prompt, highest_rated_state)\n            #     except Exception as e:\n            #         logger.error(f\"Error in generating solution: {e}\")\n            #         solution = None  # Set a fallback value for solution"
        },
        {
            "comment": "The code checks if there is a solution and returns it, otherwise, it finds the highest rated state using DFS, generates a solution from that state, and returns it. If there is an error during execution, it logs the error and returns None.",
            "location": "\"/media/root/Prima/works/tree-of-thoughts/docs/src/tree_of_thoughts/treeofthoughts.py\":140-171",
            "content": "            #     return solution if solution is not None else highest_rated_state  # Return highest rated state if solution is None\n            if state_values:\n                highest_rated_solution = max(\n                    state_values.items(), key=lambda x: x[1]\n                )\n                highest_rated_state = highest_rated_solution[0]\n                solution = self.model.generate_solution(\n                    initial_prompt, highest_rated_state\n                )\n                print(\n                    \"Highest_rated solution:\"\n                    f\" {highest_rated_solution} highest_rated_solution:\"\n                    f\" {highest_rated_solution} Solution: {solution}\"\n                )\n                return solution if solution else highest_rated_state\n            else:\n                return None\n        except Exception as e:\n            logger.error(f\"Error in tot_bfs: {e}\")\n            return None\n###########\nclass TreeofThoughtsDFS(TreeofThoughts):\n    def solve(\n        self,\n        initial_prompt,"
        },
        {
            "comment": "The code defines a function that performs Depth-First Search (DFS) to explore the thought space and evaluate potential thoughts. It takes in parameters for maximum steps, pruning threshold, and others. The function generates initial thoughts, evaluates them, filters out lower-scoring ones, and continues DFS on the remaining thoughts until max_steps is reached or all thoughts are exhausted.",
            "location": "\"/media/root/Prima/works/tree-of-thoughts/docs/src/tree_of_thoughts/treeofthoughts.py\":172-202",
            "content": "        num_thoughts,\n        max_steps,\n        value_threshold,\n        pruning_threshold=0.5,\n    ):\n        output = []\n        def dfs(state, step):\n            nonlocal output\n            if step > max_steps:\n                thought = self.model.generate_thoughts(state, 1, initial_prompt)\n                value = self.model.evaluate_states({state}, initial_prompt)[\n                    state\n                ]\n                output.append((thought, value))\n                return\n            thoughts = self.model.generate_thoughts(\n                state, self.num_thoughts, initial_prompt\n            )\n            evaluated_thoughts = self.model.evaluate_states(\n                {thought: 0 for thought in thoughts}, initial_prompt\n            )\n            filtered_thoughts = [\n                thought\n                for thought in thoughts\n                if evaluated_thoughts[thought] >= self.pruning_threshold\n            ]\n            for next_state in filtered_thoughts:\n                state_value = self.model.evaluate_states("
        },
        {
            "comment": "This code is implementing a best-first search algorithm using a priority queue. It explores the state space of the quality of states, saves the tree to JSON format, and handles exceptions in case any occur during execution. The goal is to find the best solution for a given model and initial prompt.",
            "location": "\"/media/root/Prima/works/tree-of-thoughts/docs/src/tree_of_thoughts/treeofthoughts.py\":203-232",
            "content": "                    {next_state: 0}, initial_prompt\n                )[next_state]\n                if state_value > self.value_threshold:\n                    child = (\n                        (state, next_state)\n                        if isinstance(state, str)\n                        else (*state, next_state)\n                    )\n                    dfs(child, step + 1)\n        try:\n            dfs(initial_prompt, 1)\n            best_state, _ = max(output, key=lambda x: x[1])\n            solution = self.model.generate_solution(initial_prompt, best_state)\n            return solution if solution else best_state\n        except Exception as e:\n            logger.error(f\"Error in tot_dfs: {e}\")\n            return None\n# v2 => best first search => explores state space of the quality of the states\n# priority que or greedy BFS\nclass TreeofThoughtsBEST:\n    def __init__(self, model):\n        self.model = model\n        self.tree = {\"nodes\": {}}\n    def save_tree_to_json(self, file_name):\n        os.makdirs(os.path.dirname(file_name), exist_ok=True)"
        },
        {
            "comment": "This code initializes a tree of thoughts, logs new states with their evaluations, solves the tree by generating and evaluating thoughts for each state up to a certain number, and stores the tree in a JSON file. It utilizes PriorityQueue, set, and functions for thought generation and evaluation.",
            "location": "\"/media/root/Prima/works/tree-of-thoughts/docs/src/tree_of_thoughts/treeofthoughts.py\":233-264",
            "content": "        with open(file_name, \"w\") as json_file:\n            json.dump(self.tree, json_file, indent=4)\n    def log_new_state(self, state, evaluation):\n        state_key = \" | \".join(state) if isinstance(state, tuple) else state\n        if state_key in self.tree[\"nodes\"]:\n            self.tree[\"nodes\"][state_key][\"thoughts\"].append(evaluation)\n        else:\n            self.tree[\"nodes\"][\"state_key\"] = {\"thoughts\": [evaluation]}\n    def solve(self, initial_prompt, num_thoughts, max_steps, pruning_threshold):\n        visited_states = set()\n        state_queue = PriorityQueue()\n        state_queue.put((0, initial_prompt))\n        for _ in range(max_steps):\n            if state_queue.empty():\n                break\n            _, state = state_queue.get()\n            if state in visited_states:\n                continue\n            visited_states.add(state)\n            thoughts = self.model.generate_thoughts(\n                state, num_thoughts, initial_prompt\n            )\n            evaluated_thoughts = {\n                thought: self.model.evaluate_states("
        },
        {
            "comment": "The code performs a search using the A* algorithm to find the highest-rated solution for a given initial prompt. It takes in a model and parameters such as the number of thoughts, maximum steps, and generates solutions based on evaluating states and generating new states. The best state is determined based on evaluation, and the function returns either the generated solution or the best state if no solution was found.",
            "location": "\"/media/root/Prima/works/tree-of-thoughts/docs/src/tree_of_thoughts/treeofthoughts.py\":265-295",
            "content": "                    {thought: 0}, initial_prompt\n                )[thought]\n                for thought in thoughts\n            }\n            for thought, value in evaluated_thoughts.items():\n                if value >= pruning_threshold:\n                    new_state = (\n                        (state, thought)\n                        if isinstance(state, str)\n                        else (*state, thought)\n                    )\n                    state_queue.put((value, new_state))\n                    self.log_new_state(new_state, value)\n        best_state = max(visited_states, key=self.model.evaluate_states)\n        solution = self.model.generate_solution(initial_prompt, best_state)\n        print(f\"Highest_rated solution: {best_state}  Solution: {solution}\")\n        return solution if solution else best_state\n# A* search algorithm\nclass TreeofThoughtsASearch:\n    def __init__(self, model):\n        self.model = model\n    def solve(\n        self,\n        initial_prompt,\n        num_thoughts=5,\n        max_steps=30,"
        },
        {
            "comment": "The code initializes a graph search algorithm with priority queue, sets visited_states and dictionaries for g_scores, f_scores, and came_from. It then iterates through max_steps to find a goal state, breaks if none found, and returns reconstructed path if a goal is reached.",
            "location": "\"/media/root/Prima/works/tree-of-thoughts/docs/src/tree_of_thoughts/treeofthoughts.py\":296-328",
            "content": "        pruning_threshold=0.4,\n    ):\n        # the open set is implemented as a piorituve quue where the priority is -f_score\n        open_set = PriorityQueue()\n        open_set.put((0, 0, initial_prompt))\n        # the set of visited_states\n        visited_states = set()\n        # the g_scores and f-scores are stored as dictionaries\n        g_scores = {initial_prompt: 0}\n        f_scores = {\n            initial_prompt: self.model.evaluate_states(\n                {initial_prompt: 0}, initial_prompt\n            )[initial_prompt]\n        }\n        # the parent of each state is stored in a dictionary\n        came_from = {}\n        for _ in range(max_steps):\n            if open_set.empty():\n                break\n            _, _, current_state = open_set.get()\n            if self.is_goal(current_state, f_scores[current_state]):\n                return self.reconstruct_path(\n                    came_from, current_state, initial_prompt\n                )\n            thoughts = self.model.generate_thoughts(\n                current_state, num_thoughts, initial_prompt"
        },
        {
            "comment": "This code evaluates states in a tree-like structure by using a model to assign scores. It then selects the best state, updating g_scores and f_scores based on these scores. Finally, it reconstructs the path from the selected state back to the initial prompt.",
            "location": "\"/media/root/Prima/works/tree-of-thoughts/docs/src/tree_of_thoughts/treeofthoughts.py\":329-355",
            "content": "            )\n            evaluated_thoughts = {\n                thought: self.model.evaluate_states(\n                    {thought: 0}, initial_prompt\n                )[thought]\n                for thought in thoughts\n            }\n            for thought, value in evaluated_thoughts.items():\n                if value < pruning_threshold or thought in visited_states:\n                    continue\n                tentative_g_score = g_scores[current_state] + 1 / value\n                if (\n                    thought not in g_scores\n                    or tentative_g_score < g_scores[thought]\n                ):\n                    came_from[thought] = current_state\n                    g_scores[thought] = tentative_g_score\n                    f_scores[thought] = tentative_g_score + value\n                    open_set.put(\n                        (-f_scores[thought], g_scores[thought], thought)\n                    )\n        return self.reconstruct_path(came_from, current_state, initial_prompt)\n    def is_goal(self, state, score):"
        },
        {
            "comment": "The code checks if the eval state is above 0.9 and returns a boolean value. It then reconstructs the path by traversing backwards from the current state to the initial state, and generates a solution using the model. The solution or path is returned as output.",
            "location": "\"/media/root/Prima/works/tree-of-thoughts/docs/src/tree_of_thoughts/treeofthoughts.py\":356-383",
            "content": "        # if eval state is above 0.9\n        return score >= 0.9\n    def reconstruct_path(self, came_from, current_state, initial_prompt):\n        path = [current_state]\n        while current_state in came_from:\n            current_state = came_from[current_state]\n            path.append(current_state)\n        path.reverse()\n        path = self.reconstruct_path(came_from, current_state, initial_prompt)\n        solution = self.model.generate_solution(initial_prompt, path)\n        print(f\"Path: {path} solution: {solution}\")\n        return solution if solution else path\nclass MonteCarloTreeofThoughts(TreeofThoughts):\n    def __init__(self, model, objective=\"balance\"):\n        super().__init__(model)\n        self.objective = objective\n        self.solution_found = False\n        self.tree: Dict[str, Dict[str, Union[float, Dict[str, Any]]]] = {\n            \"nodes\": {},\n            \"metrics\": {\"thoughts\": {}, \"evaluations\": {}},\n        }\n    def optimize_params(self, num_thoughts, max_steps, max_states):\n        if self.objective == \"speed\":"
        },
        {
            "comment": "The code snippet is from the \"treeofthoughts.py\" file. It contains a function that adjusts the number of thoughts, max steps, and max states based on different objectives (\"reliability\" or \"balance\"). If the solution has been found, it reduces these values; otherwise, it increases them. The solve() function initializes parameters and calls monte_carlo_search().",
            "location": "\"/media/root/Prima/works/tree-of-thoughts/docs/src/tree_of_thoughts/treeofthoughts.py\":384-415",
            "content": "            num_thoughts = max(1, num_thoughts - 1)\n            max_steps = max(1, max_steps - 1)\n            max_states = max(1, max_states - 1)\n        elif self.objective == \"reliability\":\n            num_thoughts += 1\n            max_steps += 1\n            max_states += 1\n        elif self.objective == \"balanace\":\n            if self.solution_found:\n                num_thoughts = max(1, num_thoughts - 1)\n                max_steps = max(1, max_steps - 1)\n                max_states = max(1, max_states - 1)\n            else:\n                num_thoughts += 1\n                max_steps += 1\n                max_states += 1\n        return num_thoughts, max_steps, max_states\n    def solve(\n        self,\n        initial_prompt: str,\n        num_thoughts: int,\n        max_steps: int,\n        max_states: int,\n        pruning_threshold: float,\n        #   sleep_time: float,\n    ):\n        self.file_name = \"logs/tree_of_thoughts_output_montecarlo.json\"\n        return self.monte_carlo_search(\n            initial_prompt,\n            num_thoughts,"
        },
        {
            "comment": "Function `monte_carlo_search` performs a Monte Carlo tree search algorithm for generating thoughts from an initial prompt. It iteratively expands states, evaluates them, and updates the transposition table and state values. Pruning is applied based on threshold and visit counts to optimize search process.",
            "location": "\"/media/root/Prima/works/tree-of-thoughts/docs/src/tree_of_thoughts/treeofthoughts.py\":416-451",
            "content": "            max_steps,\n            max_states,\n            pruning_threshold,\n            # sleep_time,\n        )\n    # v3\n    def monte_carlo_search(\n        self,\n        initial_prompt: str,\n        num_thoughts: int,\n        max_steps: int,\n        max_states: int,\n        pruning_threshold: float,\n    ):\n        current_states = [initial_prompt]\n        state_values = {}\n        visit_counts = {initial_prompt: 0}\n        transposition_table = {}\n        best_state = None\n        best_value = float(\"-inf\")\n        for step in range(1, max_steps + 1):\n            selected_states = []\n            for state in current_states:\n                if state in transposition_table:\n                    transposition_table[state]\n                else:\n                    time.sleep(1)\n                    thoughts = self.model.generate_thoughts(\n                        state, num_thoughts, initial_prompt\n                    )\n                    time.sleep(1)\n                    evaluated_thoughts = self.model.evaluate_states("
        },
        {
            "comment": "This code is creating a transposition table and updating visit counts. It iterates over evaluated thoughts, flattens the states, updates or adds to the transposition table, and checks the visit count. If the new state's count is greater than its parent state's count, it updates the UCB1 value by adding the thought value and the square root of the visit count.",
            "location": "\"/media/root/Prima/works/tree-of-thoughts/docs/src/tree_of_thoughts/treeofthoughts.py\":452-477",
            "content": "                        thoughts, initial_prompt\n                    )\n                    for thought, value in evaluated_thoughts.items():\n                        flattened_state = (\n                            (state, thought)\n                            if isinstance(state, str)\n                            else (*state, thought)\n                        )\n                        transposition_table[flattened_state] = value\n                for thought, value in evaluated_thoughts.items():\n                    flattened_state = (\n                        (state, thought)\n                        if isinstance(state, str)\n                        else (*state, thought)\n                    )\n                    if flattened_state not in visit_counts:\n                        visit_counts[flattened_state] = 0\n                    if (\n                        visit_counts[state] > visit_counts[flattened_state]\n                        and visit_counts[flattened_state] > 0\n                    ):\n                        ucb1_value = value + np.sqrt("
        },
        {
            "comment": "This code is selecting states for a tree-based model. It uses UCB1 (Upper Confidence Bound for the first time) to select states and keeps track of visit counts, values, and best state. If too many states are selected, it only considers the top maximum_states. Finally, it saves the tree as JSON and generates a solution if a best state is found.",
            "location": "\"/media/root/Prima/works/tree-of-thoughts/docs/src/tree_of_thoughts/treeofthoughts.py\":478-502",
            "content": "                            2\n                            * np.log(visit_counts[state])\n                            / visit_counts[flattened_state]\n                        )\n                        if ucb1_value >= pruning_threshold:\n                            selected_states.append(flattened_state)\n                            state_values[flattened_state] = value\n                            # Update the best state if the current state value is greater than the best value\n                            if value > best_value:\n                                best_state = flattened_state\n                                best_value = value\n                visit_counts[state] += 1\n            if len(selected_states) > max_states:\n                current_states = selected_states[:max_states]\n            self.save_tree_to_json(self.file_name)\n        # if best_state is not None:\n        #     solution = self.model.generate_solution(initial_prompt, best_state)\n        #     return solution\n        # else:\n        #     solution = None"
        },
        {
            "comment": "This code block checks if the generated solution from the model is valid. If it's not, it returns the best_state as the final result.",
            "location": "\"/media/root/Prima/works/tree-of-thoughts/docs/src/tree_of_thoughts/treeofthoughts.py\":504-506",
            "content": "        # return None\n        solution = self.model.generate_solution(initial_prompt, best_state)\n        return solution if solution else best_state"
        }
    ]
}